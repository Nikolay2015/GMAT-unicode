//$Id: Toggle.cpp 9826 2011-08-31 22:16:42Z lindajun $
//------------------------------------------------------------------------------
//                                  Toggle
//------------------------------------------------------------------------------
// GMAT: General Mission Analysis Tool.
//
// Copyright (c) 2002-2011 United States Government as represented by the
// Administrator of The National Aeronautics and Space Administration.
// All Other Rights Reserved.
//
// Author: Darrel J. Conway
// Created: 2003/mm/dd
//
// Developed jointly by NASA/GSFC and Thinking Systems, Inc. under contract
// number S-67573-G
//
/**
 * Insert descriptive text here.
 *
 * @note Any notes here.
 */
//------------------------------------------------------------------------------


// Class automatically generated by Dev-C++ New Class wizard

#include "Toggle.hpp" // class's header file
#include "Publisher.hpp"
#include "MessageInterface.hpp"
#include "StringUtil.hpp"

//#define DEBUG_RENAME
//#define DEBUG_TOGGLE_IA
//#define DEBUG_TOGGLE_SET
//#define DEBUG_TOGGLE_INIT
//#define DEBUG_TOGGLE_EXE

// class constructor
//------------------------------------------------------------------------------
// Toggle()
//------------------------------------------------------------------------------
Toggle::Toggle() :
   GmatCommand    (wxT("Toggle")),
   toggleState    (true),
   subscriberID   (parameterCount),
   toggleStateID  (++parameterCount)
{
   ++parameterCount;
}

// class destructor
//------------------------------------------------------------------------------
// ~Toggle()
//------------------------------------------------------------------------------
Toggle::~Toggle()
{
   // insert your code here
}


//------------------------------------------------------------------------------
// Toggle(const Toggle& t)
//------------------------------------------------------------------------------
Toggle::Toggle(const Toggle& t) :
   GmatCommand        (t),
   toggleState        (t.toggleState),
   subscriberID       (t.subscriberID),
   toggleStateID      (t.toggleStateID)
{
   parameterCount = t.parameterCount;
   subNames.clear();
   subs.clear();
}


//------------------------------------------------------------------------------
// Toggle& operator=(const Toggle& t)
//------------------------------------------------------------------------------
Toggle& Toggle::operator=(const Toggle& t)
{
   if (this == &t)
      return *this;
    
   GmatCommand::operator=(t);
   toggleState = t.toggleState;
   subNames.clear();
   subs.clear();
   
   return *this;   
}


//------------------------------------------------------------------------------
// bool InterpretAction()
//------------------------------------------------------------------------------
bool Toggle::InterpretAction()
{
   // Sample string:  "Toggle Report On"
   
   subNames.clear();
   subs.clear();
   
   wxString genStr = generatingString;
   
   // Trim it first
   genStr = GmatStringUtil::Trim(genStr, GmatStringUtil::BOTH, true, true);
   
   Integer loc = genStr.find(wxT("Toggle"), 0) + 6;
   wxString str = genStr;
   while (str[loc] == wxT(' '))
      ++loc;
   Integer subEnd, commentStart;
   if ((commentStart = (Integer) genStr.find_first_of(wxT("%"), 0)) != 
       (Integer)genStr.npos)  
      subEnd = commentStart;
   else 
      subEnd = (Integer) genStr.size();
   wxString str1 = genStr.substr(loc, subEnd-loc);
   #ifdef DEBUG_TOGGLE_IA
      MessageInterface::ShowMessage(wxT("In InterpretAction, str1 = \n"));
      MessageInterface::ShowMessage(wxT("   %s\n"), str1.c_str());
   #endif

   // this command, for compatability with MATLAB, should not have
   // parentheses (except to indicate array elements), brackets, or braces
   if (!GmatStringUtil::HasNoBrackets(str, false))
   {
      wxString msg = 
         wxT("The Toggle command is not allowed to contain brackets, braces, or ")
         wxT("parentheses");
      throw CommandException(msg);
   }
   StringArray parts = GmatStringUtil::SeparateBy(str1,wxT(" "), false);
   Integer partsSz = (Integer) parts.size();
   #ifdef DEBUG_TOGGLE_IA
      MessageInterface::ShowMessage(wxT("In InterpretAction, parts = \n"));
      for (Integer jj = 0; jj < partsSz; jj++)
         MessageInterface::ShowMessage(wxT("   %s\n"), parts.at(jj).c_str());
   #endif
   if (partsSz < 2) // 'Toggle' already found
      throw CommandException(wxT("Missing field in Toggle command"));
   if (parts.at(partsSz-1) == wxT("On"))       toggleState = true;
   else if (parts.at(partsSz-1) == wxT("Off")) toggleState = false;
   else
      throw CommandException(wxT("Missing or misplaced 'On' or 'Off' in Toggle command"));
   for (Integer ii = 0; ii < partsSz-1; ii++)
   {
      if ((parts.at(ii) == wxT("On")) || (parts.at(ii) == wxT("Off")))
         throw CommandException(wxT("Too many 'On's or 'Off's in Toggle command"));
      #ifdef DEBUG_TOGGLE_IA
         MessageInterface::ShowMessage(wxT("Adding subName %s \n"), parts.at(ii).c_str());
      #endif
               
      subNames.push_back(parts.at(ii));
   }
   
   return true;
}


//------------------------------------------------------------------------------
// bool Initialize()
//------------------------------------------------------------------------------
bool Toggle::Initialize()
{
   #ifdef DEBUG_TOGGLE_INIT
      MessageInterface::ShowMessage(wxT("Toggle::Initialize() entered\n"));
   #endif
      
   GmatCommand::Initialize();
   
   Subscriber *sub;
   subs.clear();
   
   GmatBase *mapObj = NULL;
   
   for (StringArray::iterator s = subNames.begin(); s != subNames.end(); ++s) 
   {
      if ((mapObj = FindObject(*s)) != NULL) 
      {
         sub = (Subscriber *)mapObj;
         if (sub)
         {
            subs.push_back(sub);
         }
      }
      else
      {
         MessageInterface::ShowMessage
            (wxT("Toggle command cannot find subscriber %s; command has no effect for that object\n"),
             s->c_str());
      }
   }
   
   //@todo Do we need this code? Ccommented out for now (LOJ: 2009.06.01)
   //if (publisher == NULL)
   //   publisher = Publisher::Instance();
   //streamID = publisher->RegisterPublishedData(this, subNames, subNames);
   
   #ifdef DEBUG_TOGGLE_INIT
   MessageInterface::ShowMessage(wxT("There are %d subscriber(s)\n"), subs.size());
   for (std::list<Subscriber *>::iterator s = subs.begin(); s != subs.end(); ++s)
   {
      MessageInterface::ShowMessage
         (wxT("   subscriber = <%p><%s>'%s'\n"), *s,
          (*s)->GetTypeName().c_str(), (*s)->GetName().c_str());
   }
   MessageInterface::ShowMessage(wxT("Toggle::Initialize() leaving\n"));
   #endif
   
   return true;
}


//------------------------------------------------------------------------------
// bool Execute()
//------------------------------------------------------------------------------
bool Toggle::Execute()
{
   #ifdef DEBUG_TOGGLE_EXE
   MessageInterface::ShowMessage
      (wxT("Toggle::Execute() entered, There are %d subscriber(s)\n"), subNames.size());
   #ifdef DEBUG_TOGGLE_EXE_MAP
   ShowObjectMaps(wxT("In Toggle::Execute()"));
   #endif
   #endif
   
   if (currentFunction != NULL)
   {
      #ifdef DEBUG_TOGGLE_EXE
      MessageInterface::ShowMessage
         (wxT("   Inside a function, so about to refresh subscriber pointers...\n"));
      #endif
      
      Subscriber *sub;
      GmatBase *mapObj = NULL;
      
      // We need to refresh subscriber pointers here, since the CcsdsEphemerisFile
      // is created and replaces old EphemerisFile in the object map (LOJ: 2010.09.30)
      subs.clear();
      for (StringArray::iterator s = subNames.begin(); s != subNames.end(); ++s) 
      {
         if ((mapObj = FindObject(*s)) != NULL) 
         {
            sub = (Subscriber *)mapObj;
            if (sub)
            {
               subs.push_back(sub);
            }
         }
         else
         {
            MessageInterface::ShowMessage
               (wxT("Toggle command cannot find subscriber %s; command has no effect for that object\n"),
                s->c_str());
         }
      }
   }
   
   #ifdef DEBUG_TOGGLE_EXE
   MessageInterface::ShowMessage(wxT("There are %d subscriber(s)\n"), subs.size());
   for (std::list<Subscriber *>::iterator s = subs.begin(); s != subs.end(); ++s)
   {
      MessageInterface::ShowMessage
         (wxT("   subscriber = <%p><%s>'%s'\n"), *s,
          (*s)->GetTypeName().c_str(), (*s)->GetName().c_str());
   }
   #endif
   
   for (std::list<Subscriber *>::iterator s = subs.begin(); s != subs.end(); ++s)
   {
      
      #ifdef DEBUG_TOGGLE_EXE
      MessageInterface::ShowMessage
         (wxT("Toggle::Execute() calling %s->Activate(%s)\n"), (*s)->GetName().c_str(),
          toggleState ? wxT("true") : wxT("false"));
      #endif
      
      (*s)->Activate(toggleState);
   }
   
   // Why do we need this? (loj: 2008.08.01)
   // This causes an error if Toggle is used in the GmatFunction, so commented out
   // Publisher Exception: Character data provider has not registered with the Publisher.
   //char data[] = "Toggle executed\n\n";
   //publisher->Publish(streamID, data, strlen(data));
   
   BuildCommandSummary(true);
   
   #ifdef DEBUG_TOGGLE_EXE
      MessageInterface::ShowMessage(wxT("Toggle::Execute() leaving\n"));
   #endif
   
   return true;
}


//------------------------------------------------------------------------------
//  GmatBase* Clone(void) const
//------------------------------------------------------------------------------
/**
 * This method returns a clone of the Toggle.
 *
 * @return clone of the Toggle.
 *
 */
//------------------------------------------------------------------------------
GmatBase* Toggle::Clone(void) const
{
   return (new Toggle(*this));
}


//------------------------------------------------------------------------------
// virtual bool TakeAction(const wxString &action,  
//                         const wxString &actionData = "");
//------------------------------------------------------------------------------
/**
 * This method performs action.
 *
 * @param <action> action to perform
 * @param <actionData> action data associated with action
 * @return true if action successfully performed
 *
 */
//------------------------------------------------------------------------------
bool Toggle::TakeAction(const wxString &action, const wxString &actionData)
{
   #if DEBUG_TAKE_ACTION
   MessageInterface::ShowMessage
      (wxT("Toggle::TakeAction() action=%s, actionData=%s\n"),
       action.c_str(), actionData.c_str());
   #endif
   
   if (action == wxT("Clear"))
   {
      subNames.clear();
      return true;
   }

   return false;
}

//------------------------------------------------------------------------------
// const ObjectTypeArray& GetRefObjectTypeArray()
//------------------------------------------------------------------------------
/**
 * Retrieves the list of ref object types used by the Achieve.
 *
 * @return the list of object types.
 * 
 */
//------------------------------------------------------------------------------
const ObjectTypeArray& Toggle::GetRefObjectTypeArray()
{
   refObjectTypes.clear();
   refObjectTypes.push_back(Gmat::SUBSCRIBER);
   //refObjectTypes.push_back(Gmat::PARAMETER);
   return refObjectTypes;
}



//------------------------------------------------------------------------------
// const StringArray& GetRefObjectNameArray(const Gmat::ObjectType type)
//------------------------------------------------------------------------------
/**
 * Accesses arrays of names for referenced objects.
 * 
 * @param type Type of object requested.
 * 
 * @return the StringArray containing the referenced object names.
 */
//------------------------------------------------------------------------------
const StringArray& Toggle::GetRefObjectNameArray(const Gmat::ObjectType type)
{
   // There are only subscribers, so ignore object type
   return subNames;
}


//------------------------------------------------------------------------------
//  const wxString GetGeneratingString()
//------------------------------------------------------------------------------
/**
 * Method used to retrieve the string that was parsed to build this GmatCommand.
 *
 * This method is used to retrieve the GmatCommand string from the script that
 * was parsed to build the GmatCommand.  It is used to save the script line, so
 * that the script can be written to a file without inverting the steps taken to
 * set up the internal object data.  As a side benefit, the script line is
 * available in the GmatCommand structure for debugging purposes.
 *
 * @param <mode>    Specifies the type of serialization requested.
 * @param <prefix>  Optional prefix appended to the object's name. (Used for
 *                  indentation)
 * @param <useName> Name that replaces the object's name (Not yet used
 *                  in commands).
 *
 * @return The script line that defines this GmatCommand.
 */
//------------------------------------------------------------------------------
const wxString& Toggle::GetGeneratingString(Gmat::WriteMode mode,
                                                  const wxString &prefix,
                                                  const wxString &useName)
{
   generatingString = prefix + wxT("Toggle ");
   for (StringArray::iterator i = subNames.begin(); i != subNames.end(); ++i)
      generatingString += (*i) + wxT(" ");
   generatingString += ((toggleState == true) ? wxT("On;") : wxT("Off;"));
   return GmatCommand::GetGeneratingString(mode, prefix, useName);
}


//---------------------------------------------------------------------------
//  bool RenameRefObject(const Gmat::ObjectType type,
//                       const wxString &oldName, const wxString &newName)
//---------------------------------------------------------------------------
bool Toggle::RenameRefObject(const Gmat::ObjectType type,
                             const wxString &oldName,
                             const wxString &newName)
{
   #ifdef DEBUG_RENAME
   MessageInterface::ShowMessage
      (wxT("Toggle::RenameConfiguredItem() type=%s, oldName=%s, newName=%s\n"),
       GetObjectTypeString(type).c_str(), oldName.c_str(), newName.c_str());
   #endif
   
   if (type != Gmat::SUBSCRIBER)
      return true;

   for (unsigned int i=0; i<subNames.size(); i++)
   {
      if (subNames[i] == oldName)
         subNames[i] = newName;
   }

   return true;
}


//------------------------------------------------------------------------------
// wxString GetParameterText(const Integer id) const
//------------------------------------------------------------------------------
wxString Toggle::GetParameterText(const Integer id) const
{
   if (id == subscriberID)
      return wxT("Subscriber");
   else if (id == toggleStateID)
      return wxT("ToggleState");
   return GmatCommand::GetParameterText(id);
}


//------------------------------------------------------------------------------
// Integer GetParameterID(const wxString &str) const
//------------------------------------------------------------------------------
Integer Toggle::GetParameterID(const wxString &str) const
{
   if (str == wxT("Subscriber"))
      return subscriberID;
   else if (str == wxT("ToggleState"))
      return toggleStateID;
   return GmatCommand::GetParameterID(str);
}


//------------------------------------------------------------------------------
// Gmat::ParameterType GetParameterType(const Integer id) const
//------------------------------------------------------------------------------
Gmat::ParameterType Toggle::GetParameterType(const Integer id) const
{
   if (id == subscriberID)
      return Gmat::STRING_TYPE;
   return GmatCommand::GetParameterType(id);
}


//------------------------------------------------------------------------------
// wxString GetParameterTypeString(const Integer id) const
//------------------------------------------------------------------------------
wxString Toggle::GetParameterTypeString(const Integer id) const
{
   if (id == subscriberID)
      return PARAM_TYPE_STRING[Gmat::STRING_TYPE];
   return GmatCommand::GetParameterTypeString(id);
}


//------------------------------------------------------------------------------
// wxString GetStringParameter(const Integer id) const
//------------------------------------------------------------------------------
wxString Toggle::GetStringParameter(const Integer id) const
{
//   if (id == subscriberID)
//   {
//      return subNames[0]; //loj: return first subscriber for now
//   }
   //   else if (id == toggleStateID)
   if (id == toggleStateID)
   {
      if (toggleState == true)
         return wxT("On");
      else
         return wxT("Off");
   }
   
   return GmatCommand::GetStringParameter(id);
}


//------------------------------------------------------------------------------
// bool SetStringParameter(const Integer id, const wxString &value)
//------------------------------------------------------------------------------
bool Toggle::SetStringParameter(const Integer id, const wxString &value)
{

   #ifdef DEBUG_TOGGLE_SET
   MessageInterface::ShowMessage
      (wxT("Toggle::SetStringParameter() id=%d, value=%s\n"), id, value.c_str());
   #endif

   if (value == wxT(""))
      return false;
   
   if (id == subscriberID)
   {
      if (find(subNames.begin(), subNames.end(), value) == subNames.end())
         subNames.push_back(value);
      
      return true;
   }
   else if (id == toggleStateID)
   {
      if (value == wxT("On"))
         toggleState = true;
      else
         toggleState = false;

      return true;
   }
   
   return GmatCommand::SetStringParameter(id, value);
}

//------------------------------------------------------------------------------
// wxString GetStringParameter(const Integer id, const Integer index) const
//------------------------------------------------------------------------------
wxString Toggle::GetStringParameter(const Integer id,
                                       const Integer index) const
{
   if (id == subscriberID)
   {
      if (index < 0 || index >= (Integer) subNames.size())
         throw CommandException(
                  wxT("Index out-of-range for subscriber names list for Toggle command.\n"));
      return subNames.at(index); 
   }
   return GmatCommand::GetStringParameter(id, index);
}

//------------------------------------------------------------------------------
// bool SetStringParameter(const Integer id, const wxString &value,
//                         const Integer index)
//------------------------------------------------------------------------------
bool Toggle::SetStringParameter(const Integer id, 
                                const wxString &value,
                                const Integer index)
{
   if (value == wxT(""))
      return false;
   
   if (id == subscriberID)
   {
      if (index < 0 || index > (Integer) subNames.size())
         throw CommandException(
                  wxT("Index out-of-range for subscriber names list for Toggle command.\n"));
      else
      {
         if (index == (Integer) subNames.size())  subNames.push_back(value);
         else                   subNames.at(index) = value;
         
         //@todo Do we need this code? Commented out for now (LOJ: 2009.06.01)
         //if (publisher == NULL)
         //   publisher = Publisher::Instance();         
         //streamID = publisher->RegisterPublishedData(this, subNames, subNames);
      }
      
      return true;
   }
   return GmatCommand::SetStringParameter(id, value, index);
}

